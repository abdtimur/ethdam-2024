{
  "detectors": [
    {
      "argument": "abiencoderv2-array",
      "help": "Storage abiencoderv2 array",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#storage-abiencoderv2-array",
      "wiki_title": "Storage ABIEncoderV2 Array",
      "wiki_description": "`solc` versions `0.4.7`-`0.5.9` contain a [compiler bug](https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs) leading to incorrect ABI encoder usage.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n    uint[2][3] bad_arr = [[1, 2], [3, 4], [5, 6]];\n    \n    /* Array of arrays passed to abi.encode is vulnerable */\n    function bad() public {                                                                                          \n        bytes memory b = abi.encode(bad_arr);\n    }\n}\n```\n`abi.encode(bad_arr)` in a call to `bad()` will incorrectly encode the array as `[[1, 2], [2, 3], [3, 4]]` and lead to unintended behavior.\n",
      "wiki_recommendation": "Use a compiler >= `0.5.10`."
    },
    {
      "argument": "arbitrary-send-erc20",
      "help": "transferFrom uses arbitrary `from`",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom",
      "wiki_title": "Arbitrary `from` in transferFrom",
      "wiki_description": "Detect when `msg.sender` is not used as `from` in transferFrom.",
      "wiki_exploit_scenario": "\n```solidity\n    function a(address from, address to, uint256 amount) public {\n        erc20.transferFrom(from, to, am);\n    }\n```\nAlice approves this contract to spend her ERC20 tokens. Bob can call `a` and specify Alice's address as the `from` parameter in `transferFrom`, allowing him to transfer Alice's tokens to himself.",
      "wiki_recommendation": "\nUse `msg.sender` as `from` in transferFrom.\n"
    },
    {
      "argument": "arbitrary-send-erc20-permit",
      "help": "transferFrom uses arbitrary from with permit",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit",
      "wiki_title": "Arbitrary `from` in transferFrom used with permit",
      "wiki_description": "Detect when `msg.sender` is not used as `from` in transferFrom and permit is used.",
      "wiki_exploit_scenario": "\n```solidity\n    function bad(address from, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) public {\n        erc20.permit(from, address(this), value, deadline, v, r, s);\n        erc20.transferFrom(from, to, value);\n    }\n```\nIf an ERC20 token does not implement permit and has a fallback function e.g. WETH, transferFrom allows an attacker to transfer all tokens approved for this contract.",
      "wiki_recommendation": "\nEnsure that the underlying ERC20 token correctly implements a permit function.\n"
    },
    {
      "argument": "arbitrary-send-eth",
      "help": "Functions that send Ether to arbitrary destinations",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations",
      "wiki_title": "Functions that send Ether to arbitrary destinations",
      "wiki_description": "Unprotected call to a function sending Ether to an arbitrary address.",
      "wiki_exploit_scenario": "\n```solidity\ncontract ArbitrarySendEth{\n    address destination;\n    function setDestination(){\n        destination = msg.sender;\n    }\n\n    function withdraw() public{\n        destination.transfer(this.balance);\n    }\n}\n```\nBob calls `setDestination` and `withdraw`. As a result he withdraws the contract's balance.",
      "wiki_recommendation": "Ensure that an arbitrary user cannot withdraw unauthorized funds."
    },
    {
      "argument": "array-by-reference",
      "help": "Modifying storage array by value",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#modifying-storage-array-by-value",
      "wiki_title": "Modifying storage array by value",
      "wiki_description": "Detect arrays passed to a function that expects reference to a storage array",
      "wiki_exploit_scenario": "\n```solidity\ncontract Memory {\n    uint[1] public x; // storage\n\n    function f() public {\n        f1(x); // update x\n        f2(x); // do not update x\n    }\n\n    function f1(uint[1] storage arr) internal { // by reference\n        arr[0] = 1;\n    }\n\n    function f2(uint[1] arr) internal { // by value\n        arr[0] = 2;\n    }\n}\n```\n\nBob calls `f()`. Bob assumes that at the end of the call `x[0]` is 2, but it is 1.\nAs a result, Bob's usage of the contract is incorrect.",
      "wiki_recommendation": "Ensure the correct usage of `memory` and `storage` in the function parameters. Make all the locations explicit."
    },
    {
      "argument": "controlled-array-length",
      "help": "Tainted array length assignment",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment",
      "wiki_title": "Array Length Assignment",
      "wiki_description": "Detects the direct assignment of an array's length.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tuint[] testArray; // dynamic size array\n\n\tfunction f(uint usersCount) public {\n\t\t// ...\n\t\ttestArray.length = usersCount;\n\t\t// ...\n\t}\n\n\tfunction g(uint userIndex, uint val) public {\n\t\t// ...\n\t\ttestArray[userIndex] = val;\n\t\t// ...\n\t}\n}\n```\nContract storage/state-variables are indexed by a 256-bit integer.\nThe user can set the array length to `2**256-1` in order to index all storage slots. \nIn the example above, one could call the function `f` to set the array length, then call the function `g` to control any storage slot desired. \nNote that storage slots here are indexed via a hash of the indexers; nonetheless, all storage will still be accessible and could be controlled by the attacker.",
      "wiki_recommendation": "Do not allow array lengths to be set directly set; instead, opt to add values as needed.\nOtherwise, thoroughly review the contract to ensure a user-controlled variable cannot reach an array length assignment."
    },
    {
      "argument": "assembly",
      "help": "Assembly usage",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage",
      "wiki_title": "Assembly usage",
      "wiki_description": "The use of assembly is error-prone and should be avoided.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Do not use `evm` assembly."
    },
    {
      "argument": "assert-state-change",
      "help": "Assert state change",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change",
      "wiki_title": "Assert state change",
      "wiki_description": "Incorrect use of `assert()`. See Solidity best [practices](https://solidity.readthedocs.io/en/latest/control-structures.html#id4).",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\n  uint s_a;\n\n  function bad() public {\n    assert((s_a += 1) > 10);\n  }\n}\n```\nThe assert in `bad()` increments the state variable `s_a` while checking for the condition.\n",
      "wiki_recommendation": "Use `require` for invariants modifying the state."
    },
    {
      "argument": "backdoor",
      "help": "Function named backdoor (detector example)",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/trailofbits/slither/wiki/Adding-a-new-detector",
      "wiki_title": "Backdoor example",
      "wiki_description": "Plugin example",
      "wiki_exploit_scenario": "..",
      "wiki_recommendation": ".."
    },
    {
      "argument": "weak-prng",
      "help": "Weak PRNG",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG",
      "wiki_title": "Weak PRNG",
      "wiki_description": "Weak PRNG due to a modulo on `block.timestamp`, `now` or `blockhash`. These can be influenced by miners to some extent so they should be avoided.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Game {\n\n    uint reward_determining_number;\n\n    function guessing() external{\n      reward_determining_number = uint256(block.blockhash(10000)) % 10;\n    }\n}\n```\nEve is a miner. Eve calls `guessing` and re-orders the block containing the transaction. \nAs a result, Eve wins the game.",
      "wiki_recommendation": "Do not use `block.timestamp`, `now` or `blockhash` as a source of randomness"
    },
    {
      "argument": "boolean-cst",
      "help": "Misuse of Boolean constant",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant",
      "wiki_title": "Misuse of a Boolean constant",
      "wiki_description": "Detects the misuse of a Boolean constant.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tfunction f(uint x) public {\n\t\t// ...\n        if (false) { // bad!\n           // ...\n        }\n\t\t// ...\n\t}\n\n\tfunction g(bool b) public returns (bool) {\n\t\t// ...\n        return (b || true); // bad!\n\t\t// ...\n\t}\n}\n```\nBoolean constants in code have only a few legitimate uses. \nOther uses (in complex expressions, as conditionals) indicate either an error or, most likely, the persistence of faulty code.",
      "wiki_recommendation": "Verify and simplify the condition."
    },
    {
      "argument": "boolean-equal",
      "help": "Comparison to boolean constant",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality",
      "wiki_title": "Boolean equality",
      "wiki_description": "Detects the comparison to boolean constants.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tfunction f(bool x) public {\n\t\t// ...\n        if (x == true) { // bad!\n           // ...\n        }\n\t\t// ...\n\t}\n}\n```\nBoolean constants can be used directly and do not need to be compare to `true` or `false`.",
      "wiki_recommendation": "Remove the equality to the boolean constant."
    },
    {
      "argument": "shadowing-builtin",
      "help": "Built-in symbol shadowing",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing",
      "wiki_title": "Builtin Symbol Shadowing",
      "wiki_description": "Detection of shadowing built-in symbols using local variables, state variables, functions, modifiers, or events.",
      "wiki_exploit_scenario": "\n```solidity\npragma solidity ^0.4.24;\n\ncontract Bug {\n    uint now; // Overshadows current time stamp.\n\n    function assert(bool condition) public {\n        // Overshadows built-in symbol for providing assertions.\n    }\n\n    function get_next_expiration(uint earlier_time) private returns (uint) {\n        return now + 259200; // References overshadowed timestamp.\n    }\n}\n```\n`now` is defined as a state variable, and shadows with the built-in symbol `now`. The function `assert` overshadows the built-in `assert` function. Any use of either of these built-in symbols may lead to unexpected results.",
      "wiki_recommendation": "Rename the local variables, state variables, functions, modifiers, and events that shadow a builtin symbol."
    },
    {
      "argument": "cache-array-length",
      "help": "Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it.",
      "impact": "DetectorClassification.OPTIMIZATION",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#cache-array-length",
      "wiki_title": "Cache array length",
      "wiki_description": "Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it. ",
      "wiki_exploit_scenario": "\n```solidity\ncontract C\n{\n    uint[] array;\n    \n    function f() public \n    {\n        for (uint i = 0; i < array.length; i++)\n        {\n            // code that does not modify length of `array`\n        }\n    }\n}\n```\nSince the `for` loop in `f` doesn't modify `array.length`, it is more gas efficient to cache it in some local variable and use that variable instead, like in the following example:\n\n```solidity\ncontract C\n{\n    uint[] array;\n    \n    function f() public \n    {\n        uint array_length = array.length;\n        for (uint i = 0; i < array_length; i++)\n        {\n            // code that does not modify length of `array`\n        }\n    }\n}\n```\n    ",
      "wiki_recommendation": "Cache the lengths of storage arrays if they are used and not modified in `for` loops."
    },
    {
      "argument": "codex",
      "help": "Use Codex to find vulnerabilities.",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.LOW",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#codex",
      "wiki_title": "Codex",
      "wiki_description": "Use [codex](https://openai.com/blog/openai-codex/) to find vulnerabilities",
      "wiki_exploit_scenario": "N/A",
      "wiki_recommendation": "Review codex's message."
    },
    {
      "argument": "constant-function-asm",
      "help": "Constant functions using assembly code",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code",
      "wiki_title": "Constant functions using assembly code",
      "wiki_description": "\nFunctions declared as `constant`/`pure`/`view` using assembly code.\n\n`constant`/`pure`/`view` was not enforced prior to Solidity 0.5.\nStarting from Solidity 0.5, a call to a `constant`/`pure`/`view` function uses the `STATICCALL` opcode, which reverts in case of state modification.\n\nAs a result, a call to an [incorrectly labeled function may trap a contract compiled with Solidity 0.5](https://solidity.readthedocs.io/en/develop/050-breaking-changes.html#interoperability-with-older-contracts).",
      "wiki_exploit_scenario": "\n```solidity\ncontract Constant{\n    uint counter;\n    function get() public view returns(uint){\n       counter = counter +1;\n       return counter\n    }\n}\n```\n`Constant` was deployed with Solidity 0.4.25. Bob writes a smart contract that interacts with `Constant` in Solidity 0.5.0. \nAll the calls to `get` revert, breaking Bob's smart contract execution.",
      "wiki_recommendation": "Ensure the attributes of contracts compiled prior to Solidity 0.5.0 are correct."
    },
    {
      "argument": "constant-function-state",
      "help": "Constant functions changing the state",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state",
      "wiki_title": "Constant functions changing the state",
      "wiki_description": "\nFunctions declared as `constant`/`pure`/`view` change the state.\n\n`constant`/`pure`/`view` was not enforced prior to Solidity 0.5.\nStarting from Solidity 0.5, a call to a `constant`/`pure`/`view` function uses the `STATICCALL` opcode, which reverts in case of state modification.\n\nAs a result, a call to an [incorrectly labeled function may trap a contract compiled with Solidity 0.5](https://solidity.readthedocs.io/en/develop/050-breaking-changes.html#interoperability-with-older-contracts).",
      "wiki_exploit_scenario": "\n```solidity\ncontract Constant{\n    uint counter;\n    function get() public view returns(uint){\n       counter = counter +1;\n       return counter\n    }\n}\n```\n`Constant` was deployed with Solidity 0.4.25. Bob writes a smart contract that interacts with `Constant` in Solidity 0.5.0. \nAll the calls to `get` revert, breaking Bob's smart contract execution.",
      "wiki_recommendation": "Ensure that attributes of contracts compiled prior to Solidity 0.5.0 are correct."
    },
    {
      "argument": "pragma",
      "help": "If different pragma directives are used",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used",
      "wiki_title": "Different pragma directives are used",
      "wiki_description": "Detect whether different Solidity versions are used.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Use one Solidity version."
    },
    {
      "argument": "controlled-delegatecall",
      "help": "Controlled delegatecall destination",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall",
      "wiki_title": "Controlled Delegatecall",
      "wiki_description": "`Delegatecall` or `callcode` to an address controlled by the user.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Delegatecall{\n    function delegate(address to, bytes data){\n        to.delegatecall(data);\n    }\n}\n```\nBob calls `delegate` and delegates the execution to his malicious contract. As a result, Bob withdraws the funds of the contract and destructs it.",
      "wiki_recommendation": "Avoid using `delegatecall`. Use only trusted destinations."
    },
    {
      "argument": "costly-loop",
      "help": "Costly operations in a loop",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop",
      "wiki_title": "Costly operations inside a loop",
      "wiki_description": "Costly operations inside a loop might waste gas, so optimizations are justified.",
      "wiki_exploit_scenario": "\n```solidity\ncontract CostlyOperationsInLoop{\n\n    uint loop_count = 100;\n    uint state_variable=0;\n\n    function bad() external{\n        for (uint i=0; i < loop_count; i++){\n            state_variable++;\n        }\n    }\n\n    function good() external{\n      uint local_variable = state_variable;\n      for (uint i=0; i < loop_count; i++){\n        local_variable++;\n      }\n      state_variable = local_variable;\n    }\n}\n```\nIncrementing `state_variable` in a loop incurs a lot of gas because of expensive `SSTOREs`, which might lead to an `out-of-gas`.",
      "wiki_recommendation": "Use a local variable to hold the loop computation result."
    },
    {
      "argument": "constable-states",
      "help": "State variables that could be declared constant",
      "impact": "DetectorClassification.OPTIMIZATION",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant",
      "wiki_title": "State variables that could be declared constant",
      "wiki_description": "State variables that are not updated following deployment should be declared constant to save gas.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Add the `constant` attribute to state variables that never change."
    },
    {
      "argument": "immutable-states",
      "help": "State variables that could be declared immutable",
      "impact": "DetectorClassification.OPTIMIZATION",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable",
      "wiki_title": "State variables that could be declared immutable",
      "wiki_description": "State variables that are not updated following deployment should be declared immutable to save gas.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Add the `immutable` attribute to state variables that never change or are set only in the constructor."
    },
    {
      "argument": "cyclomatic-complexity",
      "help": "Detects functions with high (> 11) cyclomatic complexity",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity",
      "wiki_title": "Cyclomatic complexity",
      "wiki_description": "Detects functions with high (> 11) cyclomatic complexity.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Reduce cyclomatic complexity by splitting the function into several smaller subroutines."
    },
    {
      "argument": "dead-code",
      "help": "Functions that are not used",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code",
      "wiki_title": "Dead-code",
      "wiki_description": "Functions that are not sued.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Contract{\n    function dead_code() internal() {}\n}\n```\n`dead_code` is not used in the contract, and make the code's review more difficult.",
      "wiki_recommendation": "Remove unused functions."
    },
    {
      "argument": "delegatecall-loop",
      "help": "Payable functions using `delegatecall` inside a loop",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop",
      "wiki_title": "Payable functions using `delegatecall` inside a loop",
      "wiki_description": "Detect the use of `delegatecall` inside a loop in a payable function.",
      "wiki_exploit_scenario": "\n```solidity\ncontract DelegatecallInLoop{\n\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            address(this).delegatecall(abi.encodeWithSignature(\"addBalance(address)\", receivers[i]));\n        }\n    }\n\n    function addBalance(address a) public payable {\n        balances[a] += msg.value;\n    } \n\n}\n```\nWhen calling `bad` the same `msg.value` amount will be accredited multiple times.",
      "wiki_recommendation": "\nCarefully check that the function called by `delegatecall` is not payable/doesn't use `msg.value`.\n"
    },
    {
      "argument": "deprecated-standards",
      "help": "Deprecated Solidity Standards",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards",
      "wiki_title": "Deprecated standards",
      "wiki_description": "Detect the usage of deprecated standards.",
      "wiki_exploit_scenario": "\n```solidity\ncontract ContractWithDeprecatedReferences {\n    // Deprecated: Change block.blockhash() -> blockhash()\n    bytes32 globalBlockHash = block.blockhash(0);\n\n    // Deprecated: Change constant -> view\n    function functionWithDeprecatedThrow() public constant {\n        // Deprecated: Change msg.gas -> gasleft()\n        if(msg.gas == msg.value) {\n            // Deprecated: Change throw -> revert()\n            throw;\n        }\n    }\n\n    // Deprecated: Change constant -> view\n    function functionWithDeprecatedReferences() public constant {\n        // Deprecated: Change sha3() -> keccak256()\n        bytes32 sha3Result = sha3(\"test deprecated sha3 usage\");\n\n        // Deprecated: Change callcode() -> delegatecall()\n        address(this).callcode();\n\n        // Deprecated: Change suicide() -> selfdestruct()\n        suicide(address(0));\n    }\n}\n```",
      "wiki_recommendation": "Replace all uses of deprecated symbols."
    },
    {
      "argument": "divide-before-multiply",
      "help": "Imprecise arithmetic operations order",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply",
      "wiki_title": "Divide before multiply",
      "wiki_description": "Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tfunction f(uint n) public {\n        coins = (oldSupply / n) * interest;\n    }\n}\n```\nIf `n` is greater than `oldSupply`, `coins` will be zero. For example, with `oldSupply = 5; n = 10, interest = 2`, coins will be zero.  \nIf `(oldSupply * interest / n)` was used, `coins` would have been `1`.   \nIn general, it's usually a good idea to re-arrange arithmetic to perform multiplication before division, unless the limit of a smaller type makes this dangerous.",
      "wiki_recommendation": "Consider ordering multiplication before division."
    },
    {
      "argument": "domain-separator-collision",
      "help": "Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision",
      "wiki_title": "Domain separator collision",
      "wiki_description": "An ERC20 token has a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR(), causing unanticipated behavior for contracts using `permit` functionality.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Contract{\n    function some_collisions() external() {}\n}\n```\n`some_collision` clashes with EIP-2612's DOMAIN_SEPARATOR() and will interfere with contract's using `permit`.",
      "wiki_recommendation": "Remove or rename the function that collides with DOMAIN_SEPARATOR()."
    },
    {
      "argument": "encode-packed-collision",
      "help": "ABI encodePacked Collision",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#abi-encodePacked-collision",
      "wiki_title": "ABI encodePacked Collision",
      "wiki_description": "Detect collision due to dynamic type usages in `abi.encodePacked`",
      "wiki_exploit_scenario": "\n```solidity\ncontract Sign {\n    function get_hash_for_signature(string name, string doc) external returns(bytes32) {\n        return keccak256(abi.encodePacked(name, doc));\n    }\n}\n```\nBob calls `get_hash_for_signature` with (`bob`, `This is the content`). The hash returned is used as an ID.\nEve creates a collision with the ID using (`bo`, `bThis is the content`) and compromises the system.\n",
      "wiki_recommendation": "Do not use more than one dynamic type in `abi.encodePacked()`\n(see the [Solidity documentation](https://solidity.readthedocs.io/en/v0.5.10/abi-spec.html?highlight=abi.encodePacked#non-standard-packed-modeDynamic)). \nUse `abi.encode()`, preferably."
    },
    {
      "argument": "enum-conversion",
      "help": "Detect dangerous enum conversion",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion",
      "wiki_title": "Dangerous enum conversion",
      "wiki_description": "Detect out-of-range `enum` conversion (`solc` < `0.4.5`).",
      "wiki_exploit_scenario": "\n```solidity\n    pragma solidity 0.4.2;\n    contract Test{\n\n    enum E{a}\n\n    function bug(uint a) public returns(E){\n        return E(a);\n    }\n}\n```\nAttackers can trigger unexpected behaviour by calling `bug(1)`.",
      "wiki_recommendation": "Use a recent compiler version. If `solc` <`0.4.5` is required, check the `enum` conversion range."
    },
    {
      "argument": "external-function",
      "help": "Public function that could be declared external",
      "impact": "DetectorClassification.OPTIMIZATION",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external",
      "wiki_title": "Public function that could be declared external",
      "wiki_description": "`public` functions that are never called by the contract should be declared `external`, and its immutable parameters should be located in `calldata` to save gas.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Use the `external` attribute for functions never called from the contract, and change the location of immutable parameters to `calldata` to save gas."
    },
    {
      "argument": "function-init-state",
      "help": "Function initializing state variables",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state",
      "wiki_title": "Function Initializing State",
      "wiki_description": "Detects the immediate initialization of state variables through function calls that are not pure/constant, or that use non-constant state variable.",
      "wiki_exploit_scenario": "\n```solidity\ncontract StateVarInitFromFunction {\n\n    uint public v = set(); // Initialize from function (sets to 77)\n    uint public w = 5;\n    uint public x = set(); // Initialize from function (sets to 88)\n    address public shouldntBeReported = address(8);\n\n    constructor(){\n        // The constructor is run after all state variables are initialized.\n    }\n\n    function set() public  returns(uint)  {\n        // If this function is being used to initialize a state variable declared\n        // before w, w will be zero. If it is declared after w, w will be set.\n        if(w == 0) {\n            return 77;\n        }\n\n        return 88;\n    }\n}\n```\nIn this case, users might intend a function to return a value a state variable can initialize with, without realizing the context for the contract is not fully initialized. \nIn the example above, the same function sets two different values for state variables because it checks a state variable that is not yet initialized in one case, and is initialized in the other. \nSpecial care must be taken when initializing state variables from an immediate function call so as not to incorrectly assume the state is initialized.\n",
      "wiki_recommendation": "Remove any initialization of state variables via non-constant state variables or function calls. If variables must be set upon contract deployment, locate initialization in the constructor instead."
    },
    {
      "argument": "erc20-interface",
      "help": "Incorrect ERC20 interfaces",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface",
      "wiki_title": "Incorrect erc20 interface",
      "wiki_description": "Incorrect return values for `ERC20` functions. A contract compiled with Solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Token{\n    function transfer(address to, uint value) external;\n    //...\n}\n```\n`Token.transfer` does not return a boolean. Bob deploys the token. Alice creates a contract that interacts with it but assumes a correct `ERC20` interface implementation. Alice's contract is unable to interact with Bob's contract.",
      "wiki_recommendation": "Set the appropriate return values and types for the defined `ERC20` functions."
    },
    {
      "argument": "erc721-interface",
      "help": "Incorrect ERC721 interfaces",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface",
      "wiki_title": "Incorrect erc721 interface",
      "wiki_description": "Incorrect return values for `ERC721` functions. A contract compiled with solidity > 0.4.22 interacting with these functions will fail to execute them, as the return value is missing.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Token{\n    function ownerOf(uint256 _tokenId) external view returns (bool);\n    //...\n}\n```\n`Token.ownerOf` does not return an address like `ERC721` expects. Bob deploys the token. Alice creates a contract that interacts with it but assumes a correct `ERC721` interface implementation. Alice's contract is unable to interact with Bob's contract.",
      "wiki_recommendation": "Set the appropriate return values and vtypes for the defined `ERC721` functions."
    },
    {
      "argument": "incorrect-exp",
      "help": "Incorrect exponentiation",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-exponentiation",
      "wiki_title": "Incorrect exponentiation",
      "wiki_description": "Detect use of bitwise `xor ^` instead of exponential `**`",
      "wiki_exploit_scenario": "\n```solidity\ncontract Bug{\n    uint UINT_MAX = 2^256 - 1;\n    ...\n}\n```\nAlice deploys a contract in which `UINT_MAX` incorrectly uses `^` operator instead of `**` for exponentiation",
      "wiki_recommendation": "Use the correct operator `**` for exponentiation."
    },
    {
      "argument": "incorrect-return",
      "help": "If a `return` is incorrectly used in assembly mode.",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-return-in-assembly",
      "wiki_title": "Incorrect return in assembly",
      "wiki_description": "Detect if `return` in an assembly block halts unexpectedly the execution.",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n    function f() internal returns (uint a, uint b) {\n        assembly {\n            return (5, 6)\n        }\n    }\n\n    function g() returns (bool){\n        f();\n        return true;\n    }\n}\n```\nThe return statement in `f` will cause execution in `g` to halt.\nThe function will return 6 bytes starting from offset 5, instead of returning a boolean.",
      "wiki_recommendation": "Use the `leave` statement."
    },
    {
      "argument": "solc-version",
      "help": "Incorrect Solidity version",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity",
      "wiki_title": "Incorrect versions of Solidity",
      "wiki_description": "\n`solc` frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks.\nWe also recommend avoiding complex `pragma` statement.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "\nDeploy with a recent version of Solidity (at least 0.8.0) with no known severe issues.\n\nUse a simple pragma version that allows any of these versions.\nConsider using the latest version of Solidity for testing."
    },
    {
      "argument": "incorrect-equality",
      "help": "Dangerous strict equalities",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities",
      "wiki_title": "Dangerous strict equalities",
      "wiki_description": "Use of strict equalities that can be easily manipulated by an attacker.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Crowdsale{\n    function fund_reached() public returns(bool){\n        return this.balance == 100 ether;\n    }\n```\n`Crowdsale` relies on `fund_reached` to know when to stop the sale of tokens.\n`Crowdsale` reaches 100 Ether. Bob sends 0.1 Ether. As a result, `fund_reached` is always false and the `crowdsale` never ends.",
      "wiki_recommendation": "Don't use strict equality to determine if an account has enough Ether or tokens."
    },
    {
      "argument": "incorrect-unary",
      "help": "Dangerous unary expressions",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions",
      "wiki_title": "Dangerous unary expressions",
      "wiki_description": "Unary expressions such as `x=+1` probably typos.",
      "wiki_exploit_scenario": "\n```Solidity \ncontract Bug{\n    uint public counter;\n\n    function increase() public returns(uint){\n        counter=+1;\n        return counter;\n    }\n}\n```\n`increase()` uses `=+` instead of `+=`, so `counter` will never exceed 1.",
      "wiki_recommendation": "Remove the unary expression."
    },
    {
      "argument": "incorrect-using-for",
      "help": "Detects using-for statement usage when no function from a given library matches a given type",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-using-for-usage",
      "wiki_title": "Incorrect usage of using-for statement",
      "wiki_description": "In Solidity, it is possible to use libraries for certain types, by the `using-for` statement (`using <library> for <type>`). However, the Solidity compiler doesn't check whether a given library has at least one function matching a given type. If it doesn't, such a statement has no effect and may be confusing. ",
      "wiki_exploit_scenario": "\n    ```solidity\n    library L {\n        function f(bool) public pure {}\n    }\n    \n    using L for uint;\n    ```\n    Such a code will compile despite the fact that `L` has no function with `uint` as its first argument.",
      "wiki_recommendation": "Make sure that the libraries used in `using-for` statements have at least one function matching a type used in these statements. "
    },
    {
      "argument": "shadowing-local",
      "help": "Local variables shadowing",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing",
      "wiki_title": "Local variable shadowing",
      "wiki_description": "Detection of shadowing using local variables.",
      "wiki_exploit_scenario": "\n```solidity\npragma solidity ^0.4.24;\n\ncontract Bug {\n    uint owner;\n\n    function sensitive_function(address owner) public {\n        // ...\n        require(owner == msg.sender);\n    }\n\n    function alternate_sensitive_function() public {\n        address owner = msg.sender;\n        // ...\n        require(owner == msg.sender);\n    }\n}\n```\n`sensitive_function.owner` shadows `Bug.owner`. As a result, the use of `owner` in `sensitive_function` might be incorrect.",
      "wiki_recommendation": "Rename the local variables that shadow another component."
    },
    {
      "argument": "locked-ether",
      "help": "Contracts that lock ether",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether",
      "wiki_title": "Contracts that lock Ether",
      "wiki_description": "Contract with a `payable` function, but without a withdrawal capacity.",
      "wiki_exploit_scenario": "\n```solidity\npragma solidity 0.4.24;\ncontract Locked{\n    function receive() payable public{\n    }\n}\n```\nEvery Ether sent to `Locked` will be lost.",
      "wiki_recommendation": "Remove the payable attribute or add a withdraw function."
    },
    {
      "argument": "low-level-calls",
      "help": "Low level calls",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls",
      "wiki_title": "Low-level calls",
      "wiki_description": "The use of low-level calls is error-prone. Low-level calls do not check for [code existence](https://solidity.readthedocs.io/en/v0.4.25/control-structures.html#error-handling-assert-require-revert-and-exceptions) or call success.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Avoid low-level calls. Check the call success. If the call is meant for a contract, check for code existence."
    },
    {
      "argument": "mapping-deletion",
      "help": "Deletion on mapping containing a structure",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure",
      "wiki_title": "Deletion on mapping containing a structure",
      "wiki_description": "A deletion in a structure containing a mapping will not delete the mapping (see the [Solidity documentation](https://solidity.readthedocs.io/en/latest/types.html##delete)). The remaining data may be used to compromise the contract.",
      "wiki_exploit_scenario": "\n```solidity\n    struct BalancesStruct{\n        address owner;\n        mapping(address => uint) balances;\n    }\n    mapping(address => BalancesStruct) public stackBalance;\n\n    function remove() internal{\n         delete stackBalance[msg.sender];\n    }\n```\n`remove` deletes an item of `stackBalance`.\nThe mapping `balances` is never deleted, so `remove` does not work as intended.",
      "wiki_recommendation": "Use a lock mechanism instead of a deletion to disable structure containing a mapping."
    },
    {
      "argument": "events-access",
      "help": "Missing Events Access Control",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control",
      "wiki_title": "Missing events access control",
      "wiki_description": "Detect missing events for critical access control parameters",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n\n  modifier onlyAdmin {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  function updateOwner(address newOwner) onlyAdmin external {\n    owner = newOwner;\n  }\n}\n```\n`updateOwner()` has no event, so it is difficult to track off-chain owner changes.\n",
      "wiki_recommendation": "Emit an event for critical parameter changes."
    },
    {
      "argument": "events-maths",
      "help": "Missing Events Arithmetic",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic",
      "wiki_title": "Missing events arithmetic",
      "wiki_description": "Detect missing events for critical arithmetic parameters.",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _;\n    }\n\n    function setBuyPrice(uint256 newBuyPrice) onlyOwner public {\n        buyPrice = newBuyPrice;\n    }\n\n    function buy() external {\n     ... // buyPrice is used to determine the number of tokens purchased\n    }    \n}\n```\n`setBuyPrice()` does not emit an event, so it is difficult to track changes in the value of `buyPrice` off-chain. \n",
      "wiki_recommendation": "Emit an event for critical parameter changes."
    },
    {
      "argument": "missing-inheritance",
      "help": "Missing inheritance",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance",
      "wiki_title": "Missing inheritance",
      "wiki_description": "Detect missing inheritance.",
      "wiki_exploit_scenario": "\n```solidity\ninterface ISomething {\n    function f1() external returns(uint);\n}\n\ncontract Something {\n    function f1() external returns(uint){\n        return 42;\n    }\n}\n```\n`Something` should inherit from `ISomething`. \n",
      "wiki_recommendation": "Inherit from the missing interface or contract."
    },
    {
      "argument": "missing-zero-check",
      "help": "Missing Zero Address Validation",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation",
      "wiki_title": "Missing zero address validation",
      "wiki_description": "Detect missing zero address validation.",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n\n  modifier onlyAdmin {\n    if (msg.sender != owner) throw;\n    _;\n  }\n\n  function updateOwner(address newOwner) onlyAdmin external {\n    owner = newOwner;\n  }\n}\n```\nBob calls `updateOwner` without specifying the `newOwner`, so Bob loses ownership of the contract.\n",
      "wiki_recommendation": "Check that the address is not zero."
    },
    {
      "argument": "incorrect-modifier",
      "help": "Modifiers that can return the default value",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier",
      "wiki_title": "Incorrect modifier",
      "wiki_description": "If a modifier does not execute `_` or revert, the execution of the function will return the default value, which can be misleading for the caller.",
      "wiki_exploit_scenario": "\n```solidity\n    modidfier myModif(){\n        if(..){\n           _;\n        }\n    }\n    function get() myModif returns(uint){\n\n    }\n```\nIf the condition in `myModif` is false, the execution of `get()` will return 0.",
      "wiki_recommendation": "All the paths in a modifier must execute `_` or revert."
    },
    {
      "argument": "msg-value-loop",
      "help": "msg.value inside a loop",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop",
      "wiki_title": "`msg.value` inside a loop",
      "wiki_description": "Detect the use of `msg.value` inside a loop.",
      "wiki_exploit_scenario": "\n```solidity\ncontract MsgValueInLoop{\n\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i=0; i < receivers.length; i++) {\n            balances[receivers[i]] += msg.value;\n        }\n    }\n\n}\n```\n",
      "wiki_recommendation": "\nProvide an explicit array of amounts alongside the receivers array, and check that the sum of all amounts matches `msg.value`.\n"
    },
    {
      "argument": "calls-loop",
      "help": "Multiple calls in a loop",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop",
      "wiki_title": "Calls inside a loop",
      "wiki_description": "Calls inside a loop might lead to a denial-of-service attack.",
      "wiki_exploit_scenario": "\n```solidity\ncontract CallsInLoop{\n\n    address[] destinations;\n\n    constructor(address[] newDestinations) public{\n        destinations = newDestinations;\n    }\n\n    function bad() external{\n        for (uint i=0; i < destinations.length; i++){\n            destinations[i].transfer(i);\n        }\n    }\n\n}\n```\nIf one of the destinations has a fallback function that reverts, `bad` will always revert.",
      "wiki_recommendation": "Favor [pull over push](https://github.com/ethereum/wiki/wiki/Safety#favor-pull-over-push-for-external-calls) strategy for external calls."
    },
    {
      "argument": "multiple-constructors",
      "help": "Multiple constructor schemes",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes",
      "wiki_title": "Multiple constructor schemes",
      "wiki_description": "Detect multiple constructor definitions in the same contract (using new and old schemes).",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n    uint x;\n    constructor() public {\n        x = 0;\n    }\n    function A() public {\n        x = 1;\n    }\n    \n    function test() public returns(uint) {\n        return x;\n    }\n}\n```\nIn Solidity [0.4.22](https://github.com/ethereum/solidity/releases/tag/v0.4.23), a contract with both constructor schemes will compile. The first constructor will take precedence over the second, which may be unintended.",
      "wiki_recommendation": "Only declare one constructor, preferably using the new scheme `constructor(...)` instead of `function <contractName>(...)`."
    },
    {
      "argument": "name-reused",
      "help": "Contract's name reused",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused",
      "wiki_title": "Name reused",
      "wiki_description": "If a codebase has two contracts the similar names, the compilation artifacts\nwill not contain one of the contracts with the duplicate name.",
      "wiki_exploit_scenario": "\nBob's `truffle` codebase has two contracts named `ERC20`.\nWhen `truffle compile` runs, only one of the two contracts will generate artifacts in `build/contracts`.\nAs a result, the second contract cannot be analyzed.\n",
      "wiki_recommendation": "Rename the contract."
    },
    {
      "argument": "naming-convention",
      "help": "Conformity to Solidity naming conventions",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions",
      "wiki_title": "Conformance to Solidity naming conventions",
      "wiki_description": "\nSolidity defines a [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions) that should be followed.\n#### Rule exceptions\n- Allow constant variable name/symbol/decimals to be lowercase (`ERC20`).\n- Allow `_` at the beginning of the `mixed_case` match for private variables and unused parameters.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Follow the Solidity [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions)."
    },
    {
      "argument": "out-of-order-retryable",
      "help": "Out-of-order retryable transactions",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#out-of-order-retryable-transactions",
      "wiki_title": "Out-of-order retryable transactions",
      "wiki_description": "Out-of-order retryable transactions",
      "wiki_exploit_scenario": "\n```solidity\ncontract L1 {\n    function doStuffOnL2() external {\n        // Retryable A\n        IInbox(inbox).createRetryableTicket({\n            to: l2contract,\n            l2CallValue: 0,\n            maxSubmissionCost: maxSubmissionCost,\n            excessFeeRefundAddress: msg.sender,\n            callValueRefundAddress: msg.sender,\n            gasLimit: gasLimit,\n            maxFeePerGas: maxFeePerGas,\n            data: abi.encodeCall(l2contract.claim_rewards, ())\n        });\n        // Retryable B\n        IInbox(inbox).createRetryableTicket({\n            to: l2contract,\n            l2CallValue: 0,\n            maxSubmissionCost: maxSubmissionCost,\n            excessFeeRefundAddress: msg.sender,\n            callValueRefundAddress: msg.sender,\n            gasLimit: gas,\n            maxFeePerGas: maxFeePerGas,\n            data: abi.encodeCall(l2contract.unstake, ())\n        });\n    }\n}\n\ncontract L2 {\n    function claim_rewards() public {\n        // rewards is computed based on balance and staking period\n        uint unclaimed_rewards = _compute_and_update_rewards();\n        token.safeTransfer(msg.sender, unclaimed_rewards);\n    }\n\n    // Call claim_rewards before unstaking, otherwise you lose your rewards\n    function unstake() public {\n        _free_rewards(); // clean up rewards related variables\n        balance = balance[msg.sender];\n        balance[msg.sender] = 0;\n        staked_token.safeTransfer(msg.sender, balance);\n    }\n}\n```\nBob calls `doStuffOnL2` but the first retryable ticket calling `claim_rewards` fails. The second retryable ticket calling `unstake` is executed successfully. As a result, Bob loses his rewards.",
      "wiki_recommendation": "Do not rely on the order or successful execution of retryable tickets."
    },
    {
      "argument": "variable-scope",
      "help": "Local variables used prior their declaration",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables",
      "wiki_title": "Pre-declaration usage of local variables",
      "wiki_description": "Detects the possible usage of a variable before the declaration is stepped over (either because it is later declared, or declared in another scope).",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n    function f(uint z) public returns (uint) {\n        uint y = x + 9 + z; // 'x' is used pre-declaration\n        uint x = 7;\n\n        if (z % 2 == 0) {\n            uint max = 5;\n            // ...\n        }\n\n        // 'max' was intended to be 5, but it was mistakenly declared in a scope and not assigned (so it is zero).\n        for (uint i = 0; i < max; i++) {\n            x += 1;\n        }\n\n        return x;\n    }\n}\n```\nIn the case above, the variable `x` is used before its declaration, which may result in unintended consequences. \nAdditionally, the for-loop uses the variable `max`, which is declared in a previous scope that may not always be reached. This could lead to unintended consequences if the user mistakenly uses a variable prior to any intended declaration assignment. It also may indicate that the user intended to reference a different variable.",
      "wiki_recommendation": "Move all variable declarations prior to any usage of the variable, and ensure that reaching a variable declaration does not depend on some conditional if it is used unconditionally."
    },
    {
      "argument": "protected-vars",
      "help": "Detected unprotected variables",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables",
      "wiki_title": "Protected Variables",
      "wiki_description": "Detect unprotected variable that are marked protected",
      "wiki_exploit_scenario": "\n```solidity\ncontract Buggy{\n\n    /// @custom:security write-protection=\"onlyOwner()\"\n    address owner;\n\n    function set_protected() public onlyOwner(){\n        owner = msg.sender;\n    }\n\n    function set_not_protected() public{\n        owner = msg.sender;\n    }\n}    \n```\n`owner` must be always written by function using `onlyOwner` (`write-protection=\"onlyOwner()\"`), however anyone can call `set_not_protected`.\n",
      "wiki_recommendation": "Add access controls to the vulnerable function"
    },
    {
      "argument": "public-mappings-nested",
      "help": "Public mappings with nested variables",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables",
      "wiki_title": "Public mappings with nested variables",
      "wiki_description": "Prior to Solidity 0.5, a public mapping with nested structures returned [incorrect values](https://github.com/ethereum/solidity/issues/5520).",
      "wiki_exploit_scenario": "Bob interacts with a contract that has a public mapping with nested structures. The values returned by the mapping are incorrect, breaking Bob's usage",
      "wiki_recommendation": "Do not use public mapping with nested structures."
    },
    {
      "argument": "redundant-statements", 
      "help": "Redundant statements",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements",
      "wiki_title": "Redundant Statements",
      "wiki_description": "Detect the usage of redundant statements that have no effect.",
      "wiki_exploit_scenario": "\n```solidity\ncontract RedundantStatementsContract {\n\n    constructor() public {\n        uint; // Elementary Type Name\n        bool; // Elementary Type Name\n        RedundantStatementsContract; // Identifier\n    }\n\n    function test() public returns (uint) {\n        uint; // Elementary Type Name\n        assert; // Identifier\n        test; // Identifier\n        return 777;\n    }\n}\n```\nEach commented line references types/identifiers, but performs no action with them, so no code will be generated for such statements and they can be removed.",
      "wiki_recommendation": "Remove redundant statements if they congest code but offer no value."
    },
    {
      "argument": "reentrancy-benign",
      "help": "Benign reentrancy vulnerabilities",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2",
      "wiki_title": "Reentrancy vulnerabilities",
      "wiki_description": "\nDetection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nOnly report reentrancy that acts as a double call (see `reentrancy-eth`, `reentrancy-no-eth`).",
      "wiki_exploit_scenario": "\n```solidity\n    function callme(){\n        if( ! (msg.sender.call()() ) ){\n            throw;\n        }\n        counter += 1\n    }   \n```\n\n`callme` contains a reentrancy. The reentrancy is benign because it's exploitation would have the same effect as two consecutive calls.",
      "wiki_recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy)."
    },
    {
      "argument": "reentrancy-eth",
      "help": "Reentrancy vulnerabilities (theft of ethers)",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities",
      "wiki_title": "Reentrancy vulnerabilities",
      "wiki_description": "\nDetection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that don't involve Ether (see `reentrancy-no-eth`)",
      "wiki_exploit_scenario": "\n```solidity\n    function withdrawBalance(){\n        // send userBalance[msg.sender] Ether to msg.sender\n        // if msg.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n            throw;\n        }\n        userBalance[msg.sender] = 0;\n    }\n```\n\nBob uses the re-entrancy bug to call `withdrawBalance` two times, and withdraw more than its initial deposit to the contract.",
      "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy)."
    },
    {
      "argument": "reentrancy-events",
      "help": "Reentrancy vulnerabilities leading to out-of-order Events",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3",
      "wiki_title": "Reentrancy vulnerabilities",
      "wiki_description": "\nDetects [reentrancies](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy) that allow manipulation of the order or value of events.",
      "wiki_exploit_scenario": "\n```solidity\ncontract ReentrantContract {\n\tfunction f() external {\n\t\tif (BugReentrancyEvents(msg.sender).counter() == 1) {\n\t\t\tBugReentrancyEvents(msg.sender).count(this);\n\t\t}\n\t}\n}\ncontract Counter {\n\tuint public counter;\n\tevent Counter(uint);\n\n}\ncontract BugReentrancyEvents is Counter {\n    function count(ReentrantContract d) external {\n        counter += 1;\n        d.f();\n        emit Counter(counter);\n    }\n}\ncontract NoReentrancyEvents is Counter {\n\tfunction count(ReentrantContract d) external {\n        counter += 1;\n        emit Counter(counter);\n        d.f();\n    }\n}\n```\n\nIf the external call `d.f()` re-enters `BugReentrancyEvents`, the `Counter` events will be incorrect (`Counter(2)`, `Counter(2)`) whereas `NoReentrancyEvents` will correctly emit \n(`Counter(1)`, `Counter(2)`). This may cause issues for offchain components that rely on the values of events e.g. checking for the amount deposited to a bridge.",
      "wiki_recommendation": "Apply the [`check-effects-interactions` pattern](https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy)."
    },
    {
      "argument": "reentrancy-unlimited-gas",
      "help": "Reentrancy vulnerabilities through send and transfer",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4",
      "wiki_title": "Reentrancy vulnerabilities",
      "wiki_description": "\nDetection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nOnly report reentrancy that is based on `transfer` or `send`.",
      "wiki_exploit_scenario": "\n```solidity\n    function callme(){\n        msg.sender.transfer(balances[msg.sender]):\n        balances[msg.sender] = 0;\n    }   \n```\n\n`send` and `transfer` do not protect from reentrancies in case of gas price changes.",
      "wiki_recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy)."
    },
    {
      "argument": "reentrancy-no-eth",
      "help": "Reentrancy vulnerabilities (no theft of ethers)",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1",
      "wiki_title": "Reentrancy vulnerabilities",
      "wiki_description": "\nDetection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).\nDo not report reentrancies that involve Ether (see `reentrancy-eth`).",
      "wiki_exploit_scenario": "\n```solidity\n    function bug(){\n        require(not_called);\n        if( ! (msg.sender.call() ) ){\n            throw;\n        }\n        not_called = False;\n    }   \n```\n",
      "wiki_recommendation": "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy)."
    },
    {
      "argument": "return-bomb",
      "help": "A low level callee may consume all callers gas unexpectedly.",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#return-bomb",
      "wiki_title": "Return Bomb",
      "wiki_description": "A low level callee may consume all callers gas unexpectedly.",
      "wiki_exploit_scenario": "\n```solidity\n//Modified from https://github.com/nomad-xyz/ExcessivelySafeCall\ncontract BadGuy {\n    function youveActivateMyTrapCard() external pure returns (bytes memory) {\n        assembly{\n            revert(0, 1000000)\n        }\n    }\n}\n\ncontract Mark {\n    function oops(address badGuy) public{\n        bool success;\n        bytes memory ret;\n\n        // Mark pays a lot of gas for this copy\n        //(success, ret) = badGuy.call{gas:10000}(\n        (success, ret) = badGuy.call(\n            abi.encodeWithSelector(\n                BadGuy.youveActivateMyTrapCard.selector\n            )\n        );\n\n        // Mark may OOG here, preventing local state changes\n        //importantCleanup();\n    }\n}\n\n```\nAfter Mark calls BadGuy bytes are copied from returndata to memory, the memory expansion cost is paid. This means that when using a standard solidity call, the callee can \"returnbomb\" the caller, imposing an arbitrary gas cost. \nCallee unexpectedly makes the caller OOG. \n",
      "wiki_recommendation": "Avoid unlimited implicit decoding of returndata."
    },
    {
      "argument": "return-leave",
      "help": "If a `return` is used instead of a `leave`.",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#return-instead-of-leave-in-assembly",
      "wiki_title": "Return instead of leave in assembly",
      "wiki_description": "Detect if a `return` is used where a `leave` should be used.",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n    function f() internal returns (uint a, uint b) {\n        assembly {\n            return (5, 6)\n        }\n    }\n\n}\n```\nThe function will halt the execution, instead of returning a two uint.",
      "wiki_recommendation": "Use the `leave` statement."
    },
    {
      "argument": "reused-constructor",
      "help": "Reused base constructor",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors",
      "wiki_title": "Reused base constructors",
      "wiki_description": "Detects if the same base constructor is called with arguments from two different locations in the same inheritance hierarchy.",
      "wiki_exploit_scenario": "\n```solidity\npragma solidity ^0.4.0;\n\ncontract A{\n    uint num = 5;\n    constructor(uint x) public{\n        num += x;\n    }\n}\n\ncontract B is A{\n    constructor() A(2) public { /* ... */ }\n}\n\ncontract C is A {\n    constructor() A(3) public { /* ... */ }\n}\n\ncontract D is B, C {\n    constructor() public { /* ... */ }\n}\n\ncontract E is B {\n    constructor() A(1) public { /* ... */ }\n}\n```\nThe constructor of `A` is called multiple times in `D` and `E`:\n- `D` inherits from `B` and `C`, both of which construct `A`.\n- `E` only inherits from `B`, but `B` and `E` construct `A`.\n.",
      "wiki_recommendation": "Remove the duplicate constructor call."
    },
    {
      "argument": "rtlo",
      "help": "Right-To-Left-Override control character is used",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character",
      "wiki_title": "Right-to-Left-Override character",
      "wiki_description": "An attacker can manipulate the logic of the contract by using a right-to-left-override character (`U+202E)`.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Token\n{\n\n    address payable o; // owner\n    mapping(address => uint) tokens;\n\n    function withdraw() external returns(uint)\n    {\n        uint amount = tokens[msg.sender];\n        address payable d = msg.sender;\n        tokens[msg.sender] = 0;\n        _withdraw(/*owner\u202e/*noitanitsed*/ d, o/*\u202d\n\t\t        /*value */, amount);\n    }\n\n    function _withdraw(address payable fee_receiver, address payable destination, uint value) internal\n    {\n\t\tfee_receiver.transfer(1);\n\t\tdestination.transfer(value);\n    }\n}\n```\n\n`Token` uses the right-to-left-override character when calling `_withdraw`. As a result, the fee is incorrectly sent to `msg.sender`, and the token balance is sent to the owner.\n\n",
      "wiki_recommendation": "Special control characters must not be allowed."
    },
    {
      "argument": "shadowing-abstract",
      "help": "State variables shadowing from abstract contracts",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts",
      "wiki_title": "State variable shadowing from abstract contracts",
      "wiki_description": "Detection of state variables shadowed from abstract contracts.",
      "wiki_exploit_scenario": "\n```solidity\ncontract BaseContract{\n    address owner;\n}\n\ncontract DerivedContract is BaseContract{\n    address owner;\n}\n```\n`owner` of `BaseContract` is shadowed in `DerivedContract`.",
      "wiki_recommendation": "Remove the state variable shadowing."
    },
    {
      "argument": "incorrect-shift",
      "help": "The order of parameters in a shift instruction is incorrect.",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly",
      "wiki_title": "Incorrect shift in assembly.",
      "wiki_description": "Detect if the values in a shift operation are reversed",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n    function f() internal returns (uint a) {\n        assembly {\n            a := shr(a, 8)\n        }\n    }\n}\n```\nThe shift statement will right-shift the constant 8 by `a` bits",
      "wiki_recommendation": "Swap the order of parameters."
    },
    {
      "argument": "similar-names",
      "help": "Variable names are too similar",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar",
      "wiki_title": "Variable names too similar",
      "wiki_description": "Detect variables with names that are too similar.",
      "wiki_exploit_scenario": "Bob uses several variables with similar names. As a result, his code is difficult to review.",
      "wiki_recommendation": "Prevent variables from having similar names."
    },
    {
      "argument": "shadowing-state",
      "help": "State variables shadowing",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing",
      "wiki_title": "State variable shadowing",
      "wiki_description": "Detection of state variables shadowed.",
      "wiki_exploit_scenario": "\n```solidity\ncontract BaseContract{\n    address owner;\n\n    modifier isOwner(){\n        require(owner == msg.sender);\n        _;\n    }\n\n}\n\ncontract DerivedContract is BaseContract{\n    address owner;\n\n    constructor(){\n        owner = msg.sender;\n    }\n\n    function withdraw() isOwner() external{\n        msg.sender.transfer(this.balance);\n    }\n}\n```\n`owner` of `BaseContract` is never assigned and the modifier `isOwner` does not work.",
      "wiki_recommendation": "Remove the state variable shadowing."
    },
    {
      "argument": "storage-array",
      "help": "Signed storage integer array compiler bug",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array",
      "wiki_title": "Storage Signed Integer Array",
      "wiki_description": "`solc` versions `0.4.7`-`0.5.9` contain [a compiler bug](https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs)\nleading to incorrect values in signed integer arrays.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tint[3] ether_balances; // storage signed integer array\n\tfunction bad0() private {\n\t\t// ...\n\t\tether_balances = [-1, -1, -1];\n\t\t// ...\n\t}\n}\n```\n`bad0()` uses a (storage-allocated) signed integer array state variable to store the ether balances of three accounts.  \n`-1` is supposed to indicate uninitialized values but the Solidity bug makes these as `1`, which could be exploited by the accounts.\n",
      "wiki_recommendation": "Use a compiler version >= `0.5.10`."
    },
    {
      "argument": "suicidal",
      "help": "Functions allowing anyone to destruct the contract",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal",
      "wiki_title": "Suicidal",
      "wiki_description": "Unprotected call to a function executing `selfdestruct`/`suicide`.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Suicidal{\n    function kill() public{\n        selfdestruct(msg.sender);\n    }\n}\n```\nBob calls `kill` and destructs the contract.",
      "wiki_recommendation": "Protect access to all sensitive functions."
    },
    {
      "argument": "tautological-compare",
      "help": "Comparing a variable to itself always returns true or false, depending on comparison",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#tautological-compare",
      "wiki_title": "Tautological compare",
      "wiki_description": "A variable compared to itself is probably an error as it will always return `true` for `==`, `>=`, `<=` and always `false` for `<`, `>` and `!=`.",
      "wiki_exploit_scenario": "\n```solidity\n    function check(uint a) external returns(bool){\n        return (a >= a);\n    }\n```\n`check` always return true.",
      "wiki_recommendation": "Remove comparison or compare to different value."
    },
    {
      "argument": "timestamp",
      "help": "Dangerous usage of `block.timestamp`",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp",
      "wiki_title": "Block timestamp",
      "wiki_description": "Dangerous usage of `block.timestamp`. `block.timestamp` can be manipulated by miners.",
      "wiki_exploit_scenario": "\"Bob's contract relies on `block.timestamp` for its randomness. Eve is a miner and manipulates `block.timestamp` to exploit Bob's contract.",
      "wiki_recommendation": "Avoid relying on `block.timestamp`."
    },
    {
      "argument": "too-many-digits",
      "help": "Conformance to numeric notation best practices",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits",
      "wiki_title": "Too many digits",
      "wiki_description": "\nLiterals with many digits are difficult to read and review. Use scientific notation or suffixes to make the code more readable.\n",
      "wiki_exploit_scenario": "\n```solidity\ncontract MyContract{\n    uint 1_ether = 10000000000000000000; \n}\n```\n\nWhile `1_ether` looks like `1 ether`, it is `10 ether`. As a result, it's likely to be used incorrectly.\n",
      "wiki_recommendation": "\nUse:\n- [Ether suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#ether-units),\n- [Time suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#time-units), or\n- [The scientific notation](https://solidity.readthedocs.io/en/latest/types.html#rational-and-integer-literals)\n"
    },
    {
      "argument": "tx-origin",
      "help": "Dangerous usage of `tx.origin`",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin",
      "wiki_title": "Dangerous usage of `tx.origin`",
      "wiki_description": "`tx.origin`-based protection can be abused by a malicious contract if a legitimate user interacts with the malicious contract.",
      "wiki_exploit_scenario": "\n```solidity\ncontract TxOrigin {\n    address owner = msg.sender;\n\n    function bug() {\n        require(tx.origin == owner);\n    }\n```\nBob is the owner of `TxOrigin`. Bob calls Eve's contract. Eve's contract calls `TxOrigin` and bypasses the `tx.origin` protection.",
      "wiki_recommendation": "Do not use `tx.origin` for authorization."
    },
    {
      "argument": "tautology",
      "help": "Tautology or contradiction",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction",
      "wiki_title": "Tautology or contradiction",
      "wiki_description": "Detects expressions that are tautologies or contradictions.",
      "wiki_exploit_scenario": "\n```solidity\ncontract A {\n\tfunction f(uint x) public {\n\t\t// ...\n        if (x >= 0) { // bad -- always true\n           // ...\n        }\n\t\t// ...\n\t}\n\n\tfunction g(uint8 y) public returns (bool) {\n\t\t// ...\n        return (y < 512); // bad!\n\t\t// ...\n\t}\n}\n```\n`x` is a `uint256`, so `x >= 0` will be always true.\n`y` is a `uint8`, so `y <512` will be always true.  \n",
      "wiki_recommendation": "Fix the incorrect comparison by changing the value type or the comparison."
    },
    {
      "argument": "unchecked-lowlevel",
      "help": "Unchecked low-level calls",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls",
      "wiki_title": "Unchecked low-level calls",
      "wiki_description": "The return value of a low-level call is not checked.",
      "wiki_exploit_scenario": "\n```solidity\ncontract MyConc{\n    function my_func(address payable dst) public payable{\n        dst.call.value(msg.value)(\"\");\n    }\n}\n```\nThe return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract.\nIf the low level is used to prevent blocking operations, consider logging failed calls.\n    ",
      "wiki_recommendation": "Ensure that the return value of a low-level call is checked or logged."
    },
    {
      "argument": "unchecked-send",
      "help": "Unchecked send",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send",
      "wiki_title": "Unchecked Send",
      "wiki_description": "The return value of a `send` is not checked.",
      "wiki_exploit_scenario": "\n```solidity\ncontract MyConc{\n    function my_func(address payable dst) public payable{\n        dst.send(msg.value);\n    }\n}\n```\nThe return value of `send` is not checked, so if the send fails, the Ether will be locked in the contract.\nIf `send` is used to prevent blocking operations, consider logging the failed `send`.\n    ",
      "wiki_recommendation": "Ensure that the return value of `send` is checked or logged."
    },
    {
      "argument": "unchecked-transfer",
      "help": "Unchecked tokens transfer",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer",
      "wiki_title": "Unchecked transfer",
      "wiki_description": "The return value of an external transfer/transferFrom call is not checked",
      "wiki_exploit_scenario": "\n```solidity\ncontract Token {\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n}\ncontract MyBank{  \n    mapping(address => uint) balances;\n    Token token;\n    function deposit(uint amount) public{\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    }\n}\n```\nSeveral tokens do not revert in case of failure and return false. If one of these tokens is used in `MyBank`, `deposit` will not revert if the transfer fails, and an attacker can call `deposit` for free..",
      "wiki_recommendation": "Use `SafeERC20`, or ensure that the transfer/transferFrom return value is checked."
    },
    {
      "argument": "unimplemented-functions",
      "help": "Unimplemented functions",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions",
      "wiki_title": "Unimplemented functions",
      "wiki_description": "Detect functions that are not implemented on derived-most contracts.",
      "wiki_exploit_scenario": "\n```solidity\ninterface BaseInterface {\n    function f1() external returns(uint);\n    function f2() external returns(uint);\n}\n\ninterface BaseInterface2 {\n    function f3() external returns(uint);\n}\n\ncontract DerivedContract is BaseInterface, BaseInterface2 {\n    function f1() external returns(uint){\n        return 42;\n    }\n}\n```\n`DerivedContract` does not implement `BaseInterface.f2` or `BaseInterface2.f3`.\nAs a result, the contract will not properly compile. \nAll unimplemented functions must be implemented on a contract that is meant to be used.",
      "wiki_recommendation": "Implement all unimplemented functions in any contract you intend to use directly (not simply inherit from)."
    },
    {
      "argument": "erc20-indexed",
      "help": "Un-indexed ERC20 event parameters",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters",
      "wiki_title": "Unindexed ERC20 event parameters",
      "wiki_description": "Detects whether events defined by the `ERC20` specification that should have some parameters as `indexed` are missing the `indexed` keyword.",
      "wiki_exploit_scenario": "\n```solidity\ncontract ERC20Bad {\n    // ...\n    event Transfer(address from, address to, uint value);\n    event Approval(address owner, address spender, uint value);\n\n    // ...\n}\n```\n`Transfer` and `Approval` events should have the 'indexed' keyword on their two first parameters, as defined by the `ERC20` specification.\nFailure to include these keywords will exclude the parameter data in the transaction/block's bloom filter, so external tooling searching for these parameters may overlook them and fail to index logs from this token contract.",
      "wiki_recommendation": "Add the `indexed` keyword to event parameters that should include it, according to the `ERC20` specification."
    },
    {
      "argument": "uninitialized-fptr-cst",
      "help": "Uninitialized function pointer calls in constructors",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors",
      "wiki_title": "Uninitialized function pointers in constructors",
      "wiki_description": "solc versions `0.4.5`-`0.4.26` and `0.5.0`-`0.5.8` contain a compiler bug leading to unexpected behavior when calling uninitialized function pointers in constructors.",
      "wiki_exploit_scenario": "\n```solidity\ncontract bad0 {\n\n  constructor() public {\n    /* Uninitialized function pointer */\n    function(uint256) internal returns(uint256) a;\n    a(10);\n  }\n\n}\n```\nThe call to `a(10)` will lead to unexpected behavior because function pointer `a` is not initialized in the constructor.",
      "wiki_recommendation": "Initialize function pointers before calling. Avoid function pointers if possible."
    },
    {
      "argument": "uninitialized-local",
      "help": "Uninitialized local variables",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables",
      "wiki_title": "Uninitialized local variables",
      "wiki_description": "Uninitialized local variables.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Uninitialized is Owner{\n    function withdraw() payable public onlyOwner{\n        address to;\n        to.transfer(this.balance)\n    }\n}\n```\nBob calls `transfer`. As a result, all Ether is sent to the address `0x0` and is lost.",
      "wiki_recommendation": "Initialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability."
    },
    {
      "argument": "uninitialized-state",
      "help": "Uninitialized state variables",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables",
      "wiki_title": "Uninitialized state variables",
      "wiki_description": "Uninitialized state variables.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Uninitialized{\n    address destination;\n\n    function transfer() payable public{\n        destination.transfer(msg.value);\n    }\n}\n```\nBob calls `transfer`. As a result, the Ether are sent to the address `0x0` and are lost.\n",
      "wiki_recommendation": "\nInitialize all the variables. If a variable is meant to be initialized to zero, explicitly set it to zero to improve code readability.\n"
    },
    {
      "argument": "uninitialized-storage",
      "help": "Uninitialized storage variables",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables",
      "wiki_title": "Uninitialized storage variables",
      "wiki_description": "An uninitialized storage variable will act as a reference to the first state variable, and can override a critical variable.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Uninitialized{\n    address owner = msg.sender;\n\n    struct St{\n        uint a;\n    }\n\n    function func() {\n        St st;\n        st.a = 0x0;\n    }\n}\n```\nBob calls `func`. As a result, `owner` is overridden to `0`.\n",
      "wiki_recommendation": "Initialize all storage variables."
    },
    {
      "argument": "unprotected-upgrade",
      "help": "Unprotected upgradeable contract",
      "impact": "DetectorClassification.HIGH",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract",
      "wiki_title": "Unprotected upgradeable contract",
      "wiki_description": "Detects logic contract that can be destructed.",
      "wiki_exploit_scenario": "\n```solidity\ncontract Buggy is Initializable{\n    address payable owner;\n\n    function initialize() external initializer{\n        require(owner == address(0));\n        owner = msg.sender;\n    }\n    function kill() external{\n        require(msg.sender == owner);\n        selfdestruct(owner);\n    }\n}\n```\nBuggy is an upgradeable contract. Anyone can call initialize on the logic contract, and destruct the contract.\n",
      "wiki_recommendation": "Add a constructor to ensure `initialize` cannot be called on the logic contract."
    },
    {
      "argument": "unused-import",
      "help": "Detects unused imports",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unused-imports",
      "wiki_title": "Unused Imports",
      "wiki_description": "Importing a file that is not used in the contract likely indicates a mistake. The import should be removed until it is needed.",
      "wiki_exploit_scenario": "\n    ```solidity\n    import {A} from \"./A.sol\";\n    contract B {}\n    ```\n    B either should import from A and it was forgotten or the import is not needed and should be removed.\n    ",
      "wiki_recommendation": "Remove the unused import. If the import is needed later, it can be added back."
    },
    {
      "argument": "unused-return",
      "help": "Unused return values",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.MEDIUM",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return",
      "wiki_title": "Unused return",
      "wiki_description": "The return value of an external call is not stored in a local or state variable.",
      "wiki_exploit_scenario": "\n```solidity\ncontract MyConc{\n    using SafeMath for uint;   \n    function my_func(uint a, uint b) public{\n        a.add(b);\n    }\n}\n```\n`MyConc` calls `add` of `SafeMath`, but does not store the result in `a`. As a result, the computation has no effect.",
      "wiki_recommendation": "Ensure that all the return values of the function calls are used."
    },
    {
      "argument": "unused-state",
      "help": "Unused state variables",
      "impact": "DetectorClassification.INFORMATIONAL",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable",
      "wiki_title": "Unused state variable",
      "wiki_description": "Unused state variable.",
      "wiki_exploit_scenario": "",
      "wiki_recommendation": "Remove unused state variables."
    },
    {
      "argument": "var-read-using-this",
      "help": "Contract reads its own variable using `this`",
      "impact": "DetectorClassification.OPTIMIZATION",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#public-variable-read-in-external-context",
      "wiki_title": "Public variable read in external context",
      "wiki_description": "The contract reads its own variable using `this`, adding overhead of an unnecessary STATICCALL.",
      "wiki_exploit_scenario": "\n```solidity\ncontract C {\n    mapping(uint => address) public myMap;\n    function test(uint x) external returns(address) {\n        return this.myMap(x);\n    }\n}\n```\n",
      "wiki_recommendation": "Read the variable directly from storage instead of calling the contract."
    },
    {
      "argument": "void-cst",
      "help": "Constructor called not implemented",
      "impact": "DetectorClassification.LOW",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor",
      "wiki_title": "Void constructor",
      "wiki_description": "Detect the call to a constructor that is not implemented",
      "wiki_exploit_scenario": "\n```solidity\ncontract A{}\ncontract B is A{\n    constructor() public A(){}\n}\n```\nWhen reading `B`'s constructor definition, we might assume that `A()` initiates the contract, but no code is executed.",
      "wiki_recommendation": "Remove the constructor call."
    },
    {
      "argument": "write-after-write",
      "help": "Unused write",
      "impact": "DetectorClassification.MEDIUM",
      "confidence": "DetectorClassification.HIGH",
      "wiki": "https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write",
      "wiki_title": "Write after write",
      "wiki_description": "Detects variables that are written but never read and written again.",
      "wiki_exploit_scenario": "\n    ```solidity\n    contract Buggy{\n        function my_func() external initializer{\n            // ...\n            a = b;\n            a = c;\n            // ..\n        }\n    }\n    ```\n    `a` is first asigned to `b`, and then to `c`. As a result the first write does nothing.",
      "wiki_recommendation": "Fix or remove the writes."
    }
  ]
}
